<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Pairing and IO</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../css/custom.css">
        <link rel="stylesheet" href="../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Cofun with cofree comonads" href="../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Cofun with cofree comonads" href="../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../">Cofun with cofree comonads</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../posts/pairing_and_io.html">Pairing and IO</a></h3>
    </div>
    <div class="panel-body">
        <h1 id="recap">Recap</h1>
<p>The <a href="../posts/free_and_cofree.html">first post</a> in this series covered using free monads for DSLs, cofree comonads for interpreters, and how to pair them up. This only covered pure DSLs and interpreters.</p>
<p>The <a href="../posts/monad_transformers_and_comonad_transformers.html">second post</a> in this series tidied that code up by bringing monad transformers into play for the DSL and comonad transformers into play for the interpreter. In an aside at the end of that post I mentioned how we could update the we we do pairing to take these transformer stacks into account, and demonstrated that by adding some console <code>IO</code> into the DSL.</p>
<p>The <a href="../posts/coproducts_for_free_and_products_for_cofree.html">third post</a> in this series covered the use of coproducts and products to separate our concerns a little further.</p>
<p>Now I’ll be covering how to handle <code>IO</code> in the interpreter, and will also be using our adventures with <code>IO</code> to demonstrate how we can push the coproducts and products further.</p>
<h1 id="effects-in-the-dsl">Effects in the DSL</h1>
<p>At the start of this series, we introduced the <code>Pairing</code> typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Pairing</span> f g <span class="kw">where</span>
<span class="ot">  pair ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> r</code></pre></div>
<p>and a <code>Pairing</code> instance between <code>Cofree f</code> and <code>Free g</code>, provided that we had an instance for <code>Pairing f g</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> f g <span class="ot">=&gt;</span> <span class="dt">Pairing</span> (<span class="dt">Cofree</span> f) (<span class="dt">Free</span> g) <span class="kw">where</span>
  pair p (a <span class="fu">:&lt;</span> _ ) (<span class="dt">Pure</span> x)  <span class="fu">=</span> p a x
  pair p (_ <span class="fu">:&lt;</span> fs) (<span class="dt">Free</span> gs) <span class="fu">=</span> pair (pair p) fs gs</code></pre></div>
<p>That was fine until we wanted to add monad and comonad transformers into the mix.</p>
<p>At that point we introduced <code>pairEffect</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffect ::</span> (<span class="dt">Pairing</span> f g, <span class="dt">Comonad</span> w, <span class="dt">Monad</span> m)
           <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b <span class="ot">-&gt;</span> m r
pairEffect p s c <span class="fu">=</span> <span class="kw">do</span>
  mb <span class="ot">&lt;-</span> runFreeT c
  <span class="kw">case</span> mb <span class="kw">of</span>
    <span class="dt">Pure</span> x <span class="ot">-&gt;</span> return <span class="fu">$</span> p (extract s) x
    <span class="dt">Free</span> gs <span class="ot">-&gt;</span> pair (pairEffect p) (unwrap s) gs</code></pre></div>
<p>With <code>pair</code>, the interaction between the free monad and the cofree comonad happens when we run into the <code>Pure</code> constructor of the <code>Free</code> type.</p>
<p>We may not want to wait for that to happen when we have effects in the mix - <code>IO</code> in particular - and so <code>pairEffect</code> has been written to make sure that the effects of <code>m</code> are interleaved with the interpretation of the DSL.</p>
<p>For a demonstration of this, we’ll use <code>FreeT</code> over <code>IO</code> to interact with an interpreter via the console.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">consoleAdder' ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> m ()
consoleAdder' <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> liftIO getLine
    <span class="kw">case</span> words l <span class="kw">of</span>
      [<span class="st">&quot;add&quot;</span>, x] <span class="ot">-&gt;</span> add (read x) <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
        output <span class="fu">$</span> <span class="st">&quot;add result: &quot;</span> <span class="fu">++</span> show b
      [<span class="st">&quot;clear&quot;</span>] <span class="ot">-&gt;</span> clear
      [<span class="st">&quot;total&quot;</span>] <span class="ot">-&gt;</span> total <span class="fu">&gt;&gt;=</span> \t <span class="ot">-&gt;</span>
        output <span class="fu">$</span> <span class="st">&quot;total result: &quot;</span> <span class="fu">++</span> show t
      _ <span class="ot">-&gt;</span> output prompt
  <span class="kw">where</span>
    output <span class="fu">=</span> liftIO <span class="fu">.</span> putStrLn
    prompt <span class="fu">=</span> unlines [
             <span class="st">&quot;Commands:&quot;</span>
           , <span class="st">&quot;  add [int]&quot;</span>
           , <span class="st">&quot;  clear&quot;</span>
           , <span class="st">&quot;  total&quot;</span>
           ]

<span class="ot">consoleAdder ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> m ()
consoleAdder <span class="fu">=</span> forever consoleAdder'</code></pre></div>
<p>This is nothing fancier than parsing some input to choose which action we want, printing a help message if the input didn’t parse, and looping continuously via <code>forever</code>.</p>
<p>We can run it using <code>pairEffect</code> with our existing pure interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect (\_ r <span class="ot">-&gt;</span> r) (mkCoAdder <span class="dv">10</span> <span class="dv">0</span>) consoleAdder</code></pre></div>
<p>and we’ll be able to interact with it productively.</p>
<h1 id="effects-in-the-interpreter">Effects in the interpreter</h1>
<p>That’s good, but it is a bit unsatisfactory since we can’t do any IO in the interpreter itself.</p>
<p>Let us change <code>pairEffect</code> so that we can do IO in the interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffect ::</span> (<span class="dt">Pairing</span> f g, <span class="dt">Comonad</span> w, <span class="dt">Monad</span> m)
           <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w (m a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b <span class="ot">-&gt;</span> m r
pairEffect p s c <span class="fu">=</span> <span class="kw">do</span>
  a  <span class="ot">&lt;-</span> extract s
  mb <span class="ot">&lt;-</span> runFreeT c
  <span class="kw">case</span> mb <span class="kw">of</span>
    <span class="dt">Pure</span> x <span class="ot">-&gt;</span> return <span class="fu">$</span> p a x
    <span class="dt">Free</span> gs <span class="ot">-&gt;</span> pair (pairEffect p) (unwrap s) gs</code></pre></div>
<p>This does the effect in <code>CofreeT</code> before the effect in <code>FreeT</code>. We can alter this function or write a new one if we want the effects to happen in the opposite order, although it seems unlikely that we’ll need that.</p>
<h3 id="altering-the-effects">Altering the effects</h3>
<p>We may not always want or need the same monad stack on both the DSL and interpreter sides of things.</p>
<p>That’s easy enough to fix.</p>
<p>We can change our stack around on the <code>FreeT</code> side using <code>hoistFreeT</code> from <code>Control.Monad.Trans.Free</code> in the <a href="https://hackage.haskell.org/package/free">free</a> package:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hoistFreeT ::</span> (<span class="dt">Monad</span> m, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> f m b <span class="ot">-&gt;</span> <span class="dt">FreeT</span> f n b</code></pre></div>
<p>and we can alter the stack in <code>CofreeT</code> by using <code>fmap</code>.</p>
<p>After that, we can use things like <code>lift</code> for simple changes, or <a href="http://hackage.haskell.org/package/mmorph">mmorph</a> for more complex changes.</p>
<p>If we can come up with morphisms</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">morphL ::</span> <span class="dt">Monad</span> l <span class="ot">=&gt;</span> forall a<span class="fu">.</span> l a <span class="ot">-&gt;</span> n a</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">morphM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a</code></pre></div>
<p>we can do</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffect' ::</span> (<span class="dt">Pairing</span> f g, <span class="dt">Comonad</span> w, <span class="dt">Monad</span> l, <span class="dt">Monad</span> m, <span class="dt">Monad</span> n)
           <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w (l a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b <span class="ot">-&gt;</span> n r
pairEffect' p s c <span class="fu">=</span> pairEffect p (fmap morphL s) (hoistFreeT morphM c)</code></pre></div>
<h3 id="updating-the-console-example">Updating the console example</h3>
<p>We’ll split the console example so that the client takes care of the parsing, and the interpreter takes care of printing the results.</p>
<p>This begins with a new <code>consoleAdder</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">consoleAdder' ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m ()
consoleAdder' <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> liftIO getLine
    <span class="kw">case</span> words l <span class="kw">of</span>
      [<span class="st">&quot;add&quot;</span>, x] <span class="ot">-&gt;</span> void <span class="fu">$</span> add (read x)
      [<span class="st">&quot;clear&quot;</span>] <span class="ot">-&gt;</span> clear
      [<span class="st">&quot;total&quot;</span>] <span class="ot">-&gt;</span> void total
      _ <span class="ot">-&gt;</span> output prompt
  <span class="kw">where</span>
    output <span class="fu">=</span> liftIO <span class="fu">.</span> putStrLn
    prompt <span class="fu">=</span> unlines [
             <span class="st">&quot;Commands:&quot;</span>
           , <span class="st">&quot;  add [int]&quot;</span>
           , <span class="st">&quot;  clear&quot;</span>
           ,<span class="st">&quot;  total&quot;</span>
           ]

<span class="ot">consoleAdder ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m ()
consoleAdder <span class="fu">=</span> forever consoleAdder'</code></pre></div>
<p>We then update our interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> ()
mkCoAdder limit count <span class="fu">=</span>
    coiterT next start
  <span class="kw">where</span>
    next <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>so that it will print the results of the actions it carries out.</p>
<p>For each action, we’ll use the return value to create an <code>IO</code> action which prints the return value, and we’ll push it down to the next level of the cofree comonad.</p>
<p>We’ll do this using this helper function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addResultLogging ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">CoAdderF</span> (f a) <span class="ot">-&gt;</span> <span class="dt">CoAdderF</span> (f (<span class="dt">IO</span> ()))
addResultLogging (<span class="dt">CoAdderF</span> a c t) <span class="fu">=</span> <span class="dt">CoAdderF</span> a' c' t'
  <span class="kw">where</span>
    a' x <span class="fu">=</span>
      <span class="kw">let</span>
        (b, k) <span class="fu">=</span> a x
      <span class="kw">in</span>
        (b, putStrLn (<span class="st">&quot;add result: &quot;</span> <span class="fu">++</span> show b) <span class="fu">&lt;$</span> k)
    c' <span class="fu">=</span> return () <span class="fu">&lt;$</span> c
    t' <span class="fu">=</span>
      <span class="kw">let</span>
        (i, k) <span class="fu">=</span> t
      <span class="kw">in</span>
        (i, putStrLn (<span class="st">&quot;total result: &quot;</span> <span class="fu">++</span> show i) <span class="fu">&lt;$</span> k)</code></pre></div>
<p>We can use to make a new interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdderWithLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> (<span class="dt">IO</span> ())
mkCoAdderWithLogging limit count <span class="fu">=</span>
    coiterT (addResultLogging <span class="fu">&lt;$&gt;</span> next) (return () <span class="fu">&lt;$</span> start)
  <span class="kw">where</span>
    next <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>which we can run with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect (\_ r <span class="ot">-&gt;</span> r) (mkCoAdderWithLogging <span class="dv">10</span> <span class="dv">0</span>) consoleAdder</code></pre></div>
<p>We now have <code>IO</code> in our DSL and in our interpreter.</p>
<p>There are other variants on this these, although they’re mostly used when the <code>Pure</code> constructor of the <code>Free</code> monad is driving things. Two variants I’ve seen around the internet that seem like they’d be pretty handy are</p>
<ul>
<li>working with <code>Cofree f (a -&gt; b)</code> and <code>Free a</code></li>
<li>working with <code>Cofree f (a -&gt; m b)</code> and <code>FreeT m a</code></li>
</ul>
<h1 id="effects-with-coproducts-and-products">Effects with coproducts and products</h1>
<p>We need to work a little harder to use this with coproducts and products, but I think it’s pretty interesting.</p>
<p>For the DSL side of things, we need two things for each components</p>
<ul>
<li>the text to print in the help message</li>
<li>the parser for the input</li>
</ul>
<p>We’ll capture both of those in the <code>ConsoleClient</code> class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ConsoleClient</span> f <span class="kw">where</span>
<span class="ot">  prompt ::</span> <span class="dt">Proxy</span> (f ()) <span class="ot">-&gt;</span> [<span class="dt">String</span>]
<span class="ot">  parser ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) <span class="ot">=&gt;</span> m (f ())</code></pre></div>
<p>For the help message data, we use a <code>Proxy</code> so that we can associate the data with our instances. For the parser, we return a parser from the <a href="https://hackage.haskell.org/package/parsers">parsers</a> package.</p>
<p>We can add instances of <code>ConsoleClient</code> for each of our components:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleClient</span> <span class="dt">AddF</span> <span class="kw">where</span>
  prompt _ <span class="fu">=</span> [<span class="st">&quot;add (int)&quot;</span>]
  parser <span class="fu">=</span>
    string <span class="st">&quot;add&quot;</span> <span class="fu">&gt;&gt;</span>
    space <span class="fu">&gt;&gt;</span>
    many digit <span class="fu">&gt;&gt;=</span> \xs <span class="ot">-&gt;</span>
    return <span class="fu">$</span> <span class="dt">Add</span> (read xs) (const ())</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleClient</span> <span class="dt">TotalF</span> <span class="kw">where</span>
  prompt _ <span class="fu">=</span> [<span class="st">&quot;total&quot;</span>]
  parser <span class="fu">=</span> <span class="kw">do</span>
    void <span class="fu">$</span> string <span class="st">&quot;total&quot;</span>
    return <span class="fu">$</span> <span class="dt">Total</span> (const ())</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleClient</span> <span class="dt">ClearF</span> <span class="kw">where</span>
  prompt _ <span class="fu">=</span> [<span class="st">&quot;clear&quot;</span>]
  parser <span class="fu">=</span> <span class="kw">do</span>
    void <span class="fu">$</span> string <span class="st">&quot;clear&quot;</span>
    return <span class="fu">$</span> <span class="dt">Clear</span> ()</code></pre></div>
<p>and we can combine these components automatically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">ConsoleClient</span> a, <span class="dt">ConsoleClient</span> b) <span class="ot">=&gt;</span> <span class="dt">ConsoleClient</span> (a <span class="fu">:+:</span> b) <span class="kw">where</span>
  prompt _ <span class="fu">=</span>
    prompt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (a ())) <span class="fu">++</span>
    prompt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (b ()))
  parser <span class="fu">=</span> try (fmap <span class="dt">InL</span> parser) <span class="fu">&lt;|&gt;</span> fmap <span class="dt">InR</span> parser</code></pre></div>
<p>These can be stitched together to form a much more general version of <code>runConsole</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runConsole' ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadIO</span> m, <span class="dt">ConsoleClient</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> f m ()
runConsole' <span class="fu">=</span>
    liftIO getLine <span class="fu">&gt;&gt;=</span>
        either (\_ <span class="ot">-&gt;</span> output help) liftF <span class="fu">.</span>
        parse parser <span class="st">&quot;console parser&quot;</span>
  <span class="kw">where</span>
    output <span class="fu">=</span> liftIO <span class="fu">.</span> putStrLn
    help <span class="fu">=</span> unlines <span class="fu">.</span>
      (<span class="st">&quot;Commands:&quot;</span> <span class="fu">:</span>) <span class="fu">.</span>
      map (<span class="st">&quot;  &quot;</span> <span class="fu">++</span>) <span class="fu">$</span>
      prompt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (f ()))

<span class="ot">runConsole ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadIO</span> m, <span class="dt">ConsoleClient</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> f m ()
runConsole <span class="fu">=</span> forever runConsole'</code></pre></div>
<p>The main step here is to read a line, parse it, and then either lift the parsed value to our <code>FreeT</code> if the parse succeeds or print the help message if the parse fails.</p>
<p>Unsurprisingly, we can also abstract the changes to the interpreter on a per component basis.</p>
<p>To begin with, we’ll generalize <code>addResultLogging</code> to a class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ConsoleInterpreter</span> f <span class="kw">where</span>
<span class="ot">  addResultLogging ::</span> <span class="dt">Functor</span> g <span class="ot">=&gt;</span> f (g a) <span class="ot">-&gt;</span> f (g (<span class="dt">IO</span> ()))</code></pre></div>
<p>We can create instances for each of our components:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleInterpreter</span> <span class="dt">CoAddF</span> <span class="kw">where</span>
  addResultLogging (<span class="dt">CoAdd</span> f) <span class="fu">=</span> <span class="dt">CoAdd</span> (fmap (\(b, k) <span class="ot">-&gt;</span> (b, putStrLn (<span class="st">&quot;add result: &quot;</span> <span class="fu">++</span> show b) <span class="fu">&lt;$</span> k)) f)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleInterpreter</span> <span class="dt">CoTotalF</span> <span class="kw">where</span>
  addResultLogging (<span class="dt">CoTotal</span> (i, k)) <span class="fu">=</span> <span class="dt">CoTotal</span> (i, putStrLn (<span class="st">&quot;total result: &quot;</span> <span class="fu">++</span> show i) <span class="fu">&lt;$</span> k)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleInterpreter</span> <span class="dt">CoClearF</span> <span class="kw">where</span>
  addResultLogging (<span class="dt">CoClear</span> k) <span class="fu">=</span> <span class="dt">CoClear</span> (return () <span class="fu">&lt;$</span> k)</code></pre></div>
<p>and we can stitch them all together generically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">ConsoleInterpreter</span> a, <span class="dt">ConsoleInterpreter</span> b) <span class="ot">=&gt;</span> <span class="dt">ConsoleInterpreter</span> (a <span class="fu">:*:</span> b) <span class="kw">where</span>
  addResultLogging (a <span class="fu">:*:</span> b) <span class="fu">=</span> addResultLogging a <span class="fu">:*:</span> addResultLogging b</code></pre></div>
<p>We can now update <code>mkCoAdder</code> exactly as we did before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdderWithLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> (<span class="dt">IO</span> ())
mkCoAdderWithLogging limit count <span class="fu">=</span>
    coiterT (addResultLogging <span class="fu">&lt;$&gt;</span> next) (return () <span class="fu">&lt;$</span> start)
  <span class="kw">where</span>
    next <span class="fu">=</span> coAdd <span class="fu">*:*</span> coClear <span class="fu">*:*</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">.</span> const <span class="fu">$</span> ()</code></pre></div>
<p>At some point it’d be nice to put together something like <code>reiterT</code>, with the goal of being able to rework a <code>CoAdder ()</code> into a <code>CoAdder (IO ())</code> more generically and without having to write a new version of <code>mkCoAdder</code>. I’ll update this post if or when I get around to it (or if someone else has a good suggestion for it).</p>
<p>We can switch from Dan Piponi’s version of <code>Pairing</code> to Ed Kmett’s version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Pairing</span> f g <span class="fu">|</span> f <span class="ot">-&gt;</span> g, g <span class="ot">-&gt;</span> f <span class="kw">where</span>
<span class="ot">  pair ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> r</code></pre></div>
<p>Adding the <code>FunctionalDependencies</code> help drive the inference, although it looks like we may need <code>UndecidableInstances</code> to get the pairing between <code>:+:</code> and <code>:*:</code> to work.</p>
<p>This lets us write <code>run</code> like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect' (\_ r <span class="ot">-&gt;</span> r) (mkCoAdderWithLogging <span class="dv">10</span> <span class="dv">0</span>) runConsole</code></pre></div>
<p>in which case the type of <code>runConsole</code> will be inferred to match the type of <code>mkCoAdderWithLogging</code>, which is pretty neat.</p>
<p>If we stick to the old version of <code>Pairing</code>, we need to add an explicit type signature for <code>runConsole</code>. We don’t get the inference, but we will get a type error if there isn’t a pairing between the underlying the functors of the free monad and cofree comonad we are using.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’re starting to build up a set of handy ideas.</p>
<p>It’s worth mentioning that this has mostly been by me wondering if I can do something, and then following the types and adapting to them to problems as I come across them. The point is that none of this is set in stone, and there are a lot of ways these things can be sliced and diced in fun ways. So if you’re branching out and hit a roadblock with some of the pieces that I’ve mentioned in these posts, try to rework it (or replace it) - if there’s any deep theory in play here it is almost entirely unintentional.</p>
<p>Next time, I’ll be pairing our DSL and interpreter over a network.</p>
<p><a href="TODO">Questions? Comments?</a></p>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on June 12, 2015 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
